<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dashboard Proambiental — Indicadores</title>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Supabase JS v2 (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

  <!-- Simple-DataTables -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/simple-datatables@latest/dist/style.css" />
  <script src="https://cdn.jsdelivr.net/npm/simple-datatables@latest" defer></script>

  <style>
    body { background: linear-gradient(180deg,#f5f7fb 0%, #ffffff 100%); }
    .card { background: white; border-radius: 12px; box-shadow: 0 10px 30px rgba(2,6,23,0.06); }
    .muted { color: #6b7280; }
    .chart-container { display:flex; justify-content:center; align-items:center; padding: 1rem 0; }
    .percent-label { font-weight:600; color:#065f46; }
    .small { font-size:0.85rem; color:#6b7280; }
    table.dataTable thead th { background: transparent; }
    .loading { opacity: 0.6; pointer-events: none; }
    .error { background: #fef2f2; border: 1px solid #fecaca; color: #dc2626; padding: 1rem; border-radius: 8px; }
    .success { background: #f0fdf4; border: 1px solid #bbf7d0; color: #166534; padding: 1rem; border-radius: 8px; }
  </style>
</head>
<body class="min-h-screen font-sans antialiased text-slate-800">

  <!-- HEADER -->
  <header class="bg-emerald-600 text-white">
    <div class="max-w-7xl mx-auto px-6 py-5 flex items-center justify-between">
      <div class="flex items-center gap-4">
        <svg class="w-8 h-8" viewBox="0 0 24 24" fill="none"><path d="M12 2l3 6 6 .5-4.5 4 1 6L12 17l-5.5 2.5 1-6L3 8.5 9 8 12 2z" fill="#fff"/></svg>
        <div>
          <h1 class="text-xl font-semibold">Dashboard Proambiental</h1>
          <p class="text-sm muted">Indicadores — comportamiento proambiental y autosustentabilidad</p>
        </div>
      </div>
      <div class="text-sm muted">Tabla: <span class="font-medium text-emerald-100">cuestionario_comportamiento_proambiental_autosustentabilidad</span></div>
    </div>
  </header>

  <main class="max-w-7xl mx-auto px-6 py-8">
    <!-- Estado de conexión -->
    <div id="connectionStatus" class="hidden mb-4"></div>

    <!-- CONTROLES -->
    <div class="grid md:grid-cols-4 gap-4 mb-6">
      <div class="card p-4">
        <label class="block text-sm text-slate-600 mb-2">Indicador</label>
        <select id="selectIndicator" class="w-full rounded-lg border py-2 px-3"></select>
        <p class="text-xs muted mt-2">Selecciona el indicador para analizar.</p>
      </div>

      <div class="card p-4">
        <label class="block text-sm text-slate-600 mb-2">Tipo de gráfico</label>
        <select id="selectChartType" class="w-full rounded-lg border py-2 px-3">
          <option value="bar">Barras</option>
          <option value="pie">Pastel</option>
          <option value="doughnut">Doughnut</option>
          <option value="line">Línea</option>
        </select>
        <p class="text-xs muted mt-2">Cambia la visualización.</p>
      </div>

      <div class="card p-4">
        <label class="block text-sm text-slate-600 mb-2">Filtros</label>
        <div class="flex gap-2">
          <select id="filterSexo" class="flex-1 rounded-lg border py-2 px-3">
            <option value="todos">Sexo: Todos</option>
            <option value="A">Masculino</option>
            <option value="B">Femenino</option>
          </select>
          <select id="filterGrupo" class="w-40 rounded-lg border py-2 px-3">
            <option value="todos">Grupo: Todos</option>
          </select>
        </div>
        <p class="text-xs muted mt-2">Filtros aplican en tiempo real.</p>
      </div>

      <div class="card p-4 flex flex-col justify-between">
        <div>
          <label class="block text-sm text-slate-600 mb-2">Exportar</label>
          <div class="flex gap-2">
            <button id="btnExportChart" class="flex-1 bg-emerald-600 hover:bg-emerald-700 text-white px-4 py-2 rounded-lg">Exportar gráfico</button>
            <button id="btnExportCSV" class="bg-slate-100 hover:bg-slate-200 text-slate-700 px-3 py-2 rounded-lg">Exportar CSV</button>
          </div>
        </div>

        <div class="mt-3 small">
          Actualización: automática (filtros, indicador y datos en tiempo real).
        </div>
      </div>
    </div>

    <!-- TARJETAS RESUMEN -->
    <div class="grid md:grid-cols-3 gap-4 mb-6">
      <div class="card p-5">
        <div class="text-sm muted">Resumen general</div>
        <div id="cardTotal" class="text-2xl font-semibold mt-2">—</div>
        <div class="small mt-1 muted">Total de respuestas (con filtros aplicados)</div>
      </div>

      <div class="card p-5">
        <div class="text-sm muted">Principales estadísticas</div>
        <div id="cardNumeric" class="mt-2 space-y-1">
          <!-- se llenará dinamicamente -->
        </div>
        <div class="small mt-1 muted">Distribución de categorías</div>
      </div>

      <div class="card p-5">
        <div class="text-sm muted">Variación</div>
        <div id="cardVariation" class="mt-2 space-y-1">
          <!-- varianza y desviación -->
        </div>
        <div class="small mt-1 muted">Diversidad de respuestas</div>
      </div>
    </div>

    <!-- GRAFICO CENTRADO -->
    <div class="card p-6 mb-6">
      <div class="flex items-center justify-between mb-4">
        <div>
          <h2 id="chartTitle" class="text-lg font-semibold">Indicador</h2>
          <p id="chartSubtitle" class="text-xs muted mt-1"></p>
        </div>
        <div id="chartPercentLegend" class="text-right small muted"></div>
      </div>

      <div class="chart-container">
        <canvas id="mainChart" style="max-width:900px; width:100%; height: 400px;"></canvas>
      </div>

      <div id="noDataMsg" class="text-center muted mt-4 hidden">No hay datos para los filtros aplicados.</div>
    </div>

    <!-- TABLA DISTRIBUCION Y ESTADISTICAS -->
    <div class="card p-6 mb-8">
      <div class="flex items-center justify-between mb-4">
        <div>
          <h3 class="text-lg font-semibold">Distribución del indicador</h3>
          <p class="text-xs muted mt-1">Tabla interactiva con conteo, porcentaje y estadísticas avanzadas (vinculada a filtros).</p>
        </div>
      </div>

      <div class="overflow-x-auto mb-4">
        <table id="distTable" class="w-full">
          <thead>
            <tr>
              <th>Categoria / Valor</th>
              <th>Conteo</th>
              <th>Porcentaje</th>
            </tr>
          </thead>
          <tbody id="distBody"></tbody>
        </table>
      </div>

      <div class="grid md:grid-cols-2 gap-4">
        <div class="p-4 border rounded">
          <h4 class="font-semibold">Estadísticas descriptivas</h4>
          <div id="numericStats" class="mt-2 small muted"></div>
        </div>
        <div class="p-4 border rounded">
          <h4 class="font-semibold">Resumen estadístico</h4>
          <div id="summaryStats" class="mt-2 small muted"></div>
        </div>
      </div>
    </div>

  </main>

  <script>
  /***************************************************************************
   * CONFIG SUPABASE
   ***************************************************************************/
  const SUPABASE_URL = "https://dutapywxsiuxboqsjqvf.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImR1dGFweXd4c2l1eGJvcXNqcXZmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3MTk1MTUsImV4cCI6MjA2OTI5NTUxNX0.SBIDeV_WAWlyLs-ROD1ibXtqqY5bbbh0gouY8gRB9Y4";
  const TABLE = "cuestionario_comportamiento_proambiental_autosustentabilidad";
  
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  /***************************************************************************
   * INDICATORS - Actualizado según la estructura real de la encuesta
   ***************************************************************************/
  const INDICATORS = [
    { value: 'sexo', label: 'Sexo', type: 'categorical', options: { 'A': 'Masculino', 'B': 'Femenino' } },
    { value: 'estado_civil', label: 'Estado civil', type: 'categorical', options: { 'A': 'Soltero', 'B': 'Casado', 'C': 'Unión libre', 'D': 'Divorciado' } },
    { value: 'educacion_jefe_hogar', label: 'Educación del jefe del hogar', type: 'categorical', options: { 'A': 'Primaria', 'B': 'Secundaria', 'C': 'Universidad', 'D': 'Postgrado' } },
    { value: 'situacion_laboral_jefe_hogar', label: 'Situación laboral', type: 'categorical', options: { 'A': 'Desempleado', 'B': 'Temporal', 'C': 'Empleado' } },
    { value: 'ingreso_mensual_jefe_hogar', label: 'Ingreso mensual', type: 'categorical', options: { 'A': 'Menor al sueldo básico', 'B': 'Sueldo básico', 'C': 'Mayor al sueldo básico' } },
    { value: 'conoce_desechos_solidos', label: 'Conoce desechos sólidos', type: 'likert' },
    { value: 'clasificacion_correcta_desechos', label: 'Clasificación correcta', type: 'likert' },
    { value: 'separar_desechos_por_origen', label: 'Separa desechos', type: 'likert' },
    { value: 'dedica_tiempo_reducir_reutilizar_reciclar', label: 'Dedica tiempo a reducir/reutilizar/reciclar', type: 'likert' },
    { value: 'desechos_hogar_reutilizados', label: 'Desechos reutilizados en hogar', type: 'likert' },
    { value: 'participaria_talleres_buenas_practicas', label: 'Participaría en talleres', type: 'likert' },
    { value: 'manejo_adecuado_desechos_impacto_ambiente', label: 'Impacto del manejo adecuado', type: 'likert' },
    { value: 'edad', label: 'Edad', type: 'numeric' },
    { value: 'num_integrantes_familia', label: 'Número de integrantes familia', type: 'numeric' }
  ];

  const LIKERT_LEVELS = [
    "Totalmente en desacuerdo", "En desacuerdo", "Indiferente", "De acuerdo", "Totalmente de acuerdo"
  ];

  const LIKERT_CODES = ['A', 'B', 'C', 'D', 'E'];

  /***************************************************************************
   * Manejo de estado de conexión
   ***************************************************************************/
  function showConnectionError(message) {
    const statusEl = document.getElementById('connectionStatus');
    statusEl.className = 'error';
    statusEl.innerHTML = `
      <div class="flex items-center justify-between">
        <div>
          <strong>Error de conexión:</strong> ${message}
        </div>
        <button onclick="this.parentElement.parentElement.classList.add('hidden')" class="text-sm bg-red-100 hover:bg-red-200 px-2 py-1 rounded">×</button>
      </div>
    `;
    statusEl.classList.remove('hidden');
  }

  function showConnectionSuccess(message) {
    const statusEl = document.getElementById('connectionStatus');
    statusEl.className = 'success';
    statusEl.innerHTML = `
      <div class="flex items-center justify-between">
        <div>
          <strong>✓ Conectado:</strong> ${message}
        </div>
        <button onclick="this.parentElement.parentElement.classList.add('hidden')" class="text-sm bg-green-200 hover:bg-green-300 px-2 py-1 rounded">×</button>
      </div>
    `;
    statusEl.classList.remove('hidden');
    setTimeout(() => statusEl.classList.add('hidden'), 5000);
  }

  /***************************************************************************
   * UTIL: normalizacion y estadisticas
   ***************************************************************************/
  function normalize(v) { 
    if (v === null || v === undefined) return null; 
    return String(v).trim(); 
  }

  function mean(arr){ if(!arr.length) return null; return arr.reduce((a,b)=>a+b,0)/arr.length; }
  function median(arr){
    if(!arr.length) return null;
    const s = arr.slice().sort((a,b)=>a-b);
    const m = Math.floor(s.length/2);
    return s.length%2 ? s[m] : (s[m-1]+s[m])/2;
  }
  function mode(arr){
    if(!arr.length) return null;
    const counts = {};
    arr.forEach(v=> counts[v] = (counts[v]||0)+1);
    let max=0, mod=null;
    Object.entries(counts).forEach(([k,c])=> { if(c>max){ max=c; mod=k; }});
    return mod;
  }
  function variance(arr){
    if(!arr.length) return null;
    const m = mean(arr);
    return arr.reduce((s,x)=> s+Math.pow(x-m,2),0)/arr.length;
  }
  function stdev(arr){ const v = variance(arr); return v===null ? null : Math.sqrt(v); }
  function sum(arr){ return arr.reduce((a,b)=>a+b,0); }
  function rangeArr(arr){ if(!arr.length) return null; return Math.max(...arr)-Math.min(...arr); }

  /***************************************************************************
   * Chart handling
   ***************************************************************************/
  let chart = null;
  function destroyChart(){ if(chart){ try{ chart.destroy(); }catch(e){} chart=null; } }

  function renderChart(type, labels, values, title){
    const ctx = document.getElementById('mainChart').getContext('2d');
    destroyChart();

    if (!labels.length || !values.length) {
      console.warn("No data to render chart");
      return;
    }

    const total = values.reduce((a,b)=>a+b,0);
    const percentData = values.map(v=> total? Math.round((v/total)*10000)/100 : 0);

    const palette = ["#2a9d8f","#e76f51","#457b9d","#f4a261","#8ab17d","#c084fc","#60a5fa","#f472b6","#9ca3af"];
    const bg = palette.slice(0, labels.length);
    
    chart = new Chart(ctx, {
      type,
      data: { 
        labels, 
        datasets:[{ 
          label: title, 
          data: values, 
          backgroundColor: bg, 
          borderColor: '#fff', 
          borderWidth: 1 
        }] 
      },
      options:{ 
        responsive: true,
        maintainAspectRatio: false,
        plugins:{ 
          legend: {
            position: 'top',
          },
          tooltip:{ 
            callbacks:{ 
              label(ctx){ 
                const i = ctx.dataIndex; 
                const v = values[i]; 
                const p = total ? Math.round((v/total)*10000)/100 : 0; 
                return `${v} respuestas (${p}%)`; 
              } 
            } 
          } 
        }
      }
    });

    const percentLegend = document.getElementById('chartPercentLegend');
    percentLegend.innerHTML = '';
    const sorted = labels.map((l,i)=>({label:l, v:values[i], p: total?Math.round((values[i]/total)*10000)/100:0})).sort((a,b)=>b.v-a.v);
    const top = sorted.slice(0,3);
    if(top.length){
      percentLegend.innerHTML = top.map(t=> `<div><span class="percent-label">${t.p}%</span> — <span class="small">${t.label}</span></div>`).join('');
    }
  }

  /***************************************************************************
   * Data handling: fetch + process
   ***************************************************************************/
  async function fetchAll(){
    try {
      console.log("Fetching data from Supabase...");
      const { data, error, status } = await supabase
        .from(TABLE)
        .select('*')
        .limit(1000);

      if(error){
        console.error("Supabase error:", error);
        let errorMsg = `Error ${status}: ${error.message}`;
        throw new Error(errorMsg);
      }
      
      console.log("Data received:", data ? data.length : 0, "registros");
      
      if (!data || data.length === 0) {
        console.warn("No se encontraron datos en la tabla");
        showConnectionSuccess("Conexión exitosa pero no hay datos en la tabla");
      } else {
        showConnectionSuccess(`Cargados ${data.length} registros`);
      }
      
      window.__RAW = data || [];
      return window.__RAW;
    } catch (error) {
      console.error("Error fetching data:", error);
      showConnectionError("No se pudieron cargar los datos: " + error.message);
      return [];
    }
  }

  function populateIndicators(){
    const sel = document.getElementById('selectIndicator');
    sel.innerHTML = '';
    INDICATORS.forEach(i=> { 
      const o = document.createElement('option'); 
      o.value = i.value; 
      o.textContent = i.label; 
      sel.appendChild(o); 
    });
  }

  function populateGroupFilter(data){
    const groups = Array.from(new Set(data.map(d=> normalize(d.grupo)).filter(Boolean)));
    const sel = document.getElementById('filterGrupo');
    sel.innerHTML = '<option value="todos">Grupo: Todos</option>';
    groups.forEach(g=> { 
      const o = document.createElement('option'); 
      o.value = g; 
      o.textContent = `Grupo: ${g}`; 
      sel.appendChild(o); 
    });
  }

  function processIndicator(indKey, rows){
    if (!rows || rows.length === 0) {
      return { labels: [], values: [], isNumeric: false, numeric: [] };
    }

    const indicator = INDICATORS.find(i => i.value === indKey);
    if (!indicator) {
      return { labels: [], values: [], isNumeric: false, numeric: [] };
    }

    const arrRaw = rows.map(r => r[indKey]).filter(v => v !== undefined && v !== null);
    if(!arrRaw.length) return { labels: [], values: [], isNumeric: false, numeric: [] };

    // Procesar según el tipo de indicador
    if (indicator.type === 'numeric') {
      const numeric = arrRaw.map(v => {
        const num = Number(v);
        return isNaN(num) ? null : num;
      }).filter(n => n !== null);
      
      if (numeric.length === 0) {
        return { labels: [], values: [], isNumeric: true, numeric: [] };
      }

      // Para datos numéricos, crear bins
      const min = Math.min(...numeric);
      const max = Math.max(...numeric);
      
      if (max - min <= 10) {
        // Pocos valores únicos, mostrar todos
        const uniqueVals = Array.from(new Set(numeric)).sort((a, b) => a - b);
        const labels = uniqueVals.map(v => String(v));
        const values = uniqueVals.map(val => numeric.filter(v => v === val).length);
        return { labels, values, isNumeric: true, numeric };
      } else {
        // Muchos valores, crear bins
        const binCount = Math.min(6, Math.ceil((max - min) / 5));
        const binSize = (max - min) / binCount;
        const labels = [];
        const values = new Array(binCount).fill(0);
        
        for (let i = 0; i < binCount; i++) {
          const binStart = min + i * binSize;
          const binEnd = min + (i + 1) * binSize;
          labels.push(`${Math.round(binStart)}-${Math.round(binEnd)}`);
        }
        
        numeric.forEach(value => {
          const binIndex = Math.min(binCount - 1, Math.floor((value - min) / binSize));
          values[binIndex]++;
        });
        
        return { labels, values, isNumeric: true, numeric };
      }
    }
    else if (indicator.type === 'likert') {
      // Procesar respuestas Likert (A, B, C, D, E)
      const values = new Array(5).fill(0);
      
      arrRaw.forEach(v => {
        const strVal = String(v).trim().toUpperCase();
        const index = LIKERT_CODES.indexOf(strVal);
        if (index !== -1) {
          values[index]++;
        } else {
          // Si no encuentra el código, buscar por texto
          const textMatch = LIKERT_LEVELS.findIndex(level => 
            level.toLowerCase().includes(strVal.toLowerCase())
          );
          if (textMatch !== -1) {
            values[textMatch]++;
          }
        }
      });
      
      return { 
        labels: LIKERT_LEVELS, 
        values: values, 
        isNumeric: false, 
        numeric: [] 
      };
    }
    else if (indicator.type === 'categorical' && indicator.options) {
      // Procesar respuestas categóricas con opciones definidas
      const counts = {};
      
      // Inicializar contadores para todas las opciones definidas
      Object.keys(indicator.options).forEach(key => {
        counts[key] = 0;
      });
      
      // Contar ocurrencias
      arrRaw.forEach(v => {
        const strVal = String(v).trim().toUpperCase();
        if (counts.hasOwnProperty(strVal)) {
          counts[strVal]++;
        }
      });
      
      // Crear arrays para labels y values, excluyendo categorías con 0 respuestas
      const labels = [];
      const values = [];
      
      Object.keys(indicator.options).forEach(key => {
        if (counts[key] > 0) {
          labels.push(indicator.options[key]);
          values.push(counts[key]);
        }
      });
      
      return { labels, values, isNumeric: false, numeric: [] };
    }
    else {
      // Procesamiento genérico para datos categóricos sin opciones definidas
      const counts = {};
      arrRaw.forEach(v => {
        const key = normalize(v) || 'No especificado';
        counts[key] = (counts[key] || 0) + 1;
      });
      
      const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);
      const labels = entries.map(e => e[0]);
      const values = entries.map(e => e[1]);
      
      return { labels, values, isNumeric: false, numeric: [] };
    }
  }

  function updateUIForIndicator(indKey, processed, filteredRows){
    const total = filteredRows.length;
    document.getElementById('cardTotal').textContent = total;

    const numericContainer = document.getElementById('cardNumeric');
    const variationContainer = document.getElementById('cardVariation');
    const numericStatsBlock = document.getElementById('numericStats');
    const summaryStatsBlock = document.getElementById('summaryStats');

    numericContainer.innerHTML = '';
    variationContainer.innerHTML = '';
    numericStatsBlock.innerHTML = '';
    summaryStatsBlock.innerHTML = '';

    if(processed.isNumeric && processed.numeric.length){
      const arr = processed.numeric;
      const mn = Math.min(...arr);
      const mx = Math.max(...arr);
      const avg = mean(arr).toFixed(1);
      const med = median(arr).toFixed(1);
      const mod = mode(arr);
      const varr = variance(arr);
      const sd = stdev(arr);
      const rng = rangeArr(arr);

      numericContainer.innerHTML = `
        <div class="text-lg font-semibold">${avg}</div>
        <div class="small muted">Promedio</div>
        <div class="mt-2">Mín: <strong>${mn}</strong> • Máx: <strong>${mx}</strong></div>
        <div>Mediana: <strong>${med}</strong></div>`;

      variationContainer.innerHTML = `
        <div>Desv. estándar: <strong>${sd!==null?sd.toFixed(2):'—'}</strong></div>
        <div>Rango: <strong>${rng!==null?rng:'—'}</strong></div>
        <div>Moda: <strong>${mod}</strong></div>`;

      numericStatsBlock.innerHTML = `
        <ul class="list-disc pl-5">
          <li>Mínimo: ${mn}</li>
          <li>Máximo: ${mx}</li>
          <li>Promedio: ${avg}</li>
          <li>Mediana: ${med}</li>
          <li>Moda: ${mod}</li>
          <li>Total muestras: ${arr.length}</li>
        </ul>`;

      summaryStatsBlock.innerHTML = `
        <ul class="list-disc pl-5">
          <li>Desviación estándar: ${sd!==null?sd.toFixed(3):'—'}</li>
          <li>Varianza: ${varr!==null?varr.toFixed(3):'—'}</li>
          <li>Rango: ${rng!==null?rng:'—'}</li>
        </ul>`;
    } else {
      // Para datos categóricos
      const totalResponses = processed.values.reduce((a, b) => a + b, 0);
      const uniqueCategories = processed.labels.length;
      const maxValue = Math.max(...processed.values);
      const maxCategory = processed.labels[processed.values.indexOf(maxValue)];

      numericContainer.innerHTML = `
        <div class="text-lg font-semibold">${uniqueCategories}</div>
        <div class="small muted">Categorías únicas</div>
        <div class="mt-2">Total respuestas: <strong>${totalResponses}</strong></div>
        <div>Moda: <strong>${maxCategory}</strong></div>`;

      variationContainer.innerHTML = `
        <div>Frecuencia máxima: <strong>${maxValue}</strong></div>
        <div>Diversidad: <strong>${uniqueCategories}</strong> categorías</div>`;

      numericStatsBlock.innerHTML = `
        <ul class="list-disc pl-5">
          <li>Total respuestas: ${totalResponses}</li>
          <li>Categorías únicas: ${uniqueCategories}</li>
          <li>Moda: "${maxCategory}" (${maxValue} respuestas)</li>
          <li>Porcentaje moda: ${totalResponses ? Math.round((maxValue/totalResponses)*100) : 0}%</li>
        </ul>`;

      summaryStatsBlock.innerHTML = `
        <ul class="list-disc pl-5">
          <li>Distribución categórica</li>
          <li>Índice de diversidad: ${uniqueCategories}</li>
          <li>Concentración: ${totalResponses ? Math.round((maxValue/totalResponses)*100) : 0}% en la categoría principal</li>
        </ul>`;
    }

    const distBody = document.getElementById('distBody');
    distBody.innerHTML = '';
    const labels = processed.labels || [];
    const values = processed.values || [];
    const totalCounts = values.reduce((a,b)=>a+b,0) || 0;

    if(!labels.length){
      document.getElementById('noDataMsg').classList.remove('hidden');
      return;
    } else {
      document.getElementById('noDataMsg').classList.add('hidden');
    }

    for(let i=0;i<labels.length;i++){
      const lab = labels[i];
      const cnt = values[i] || 0;
      const pct = totalCounts ? Math.round((cnt/totalCounts)*10000)/100 : 0;
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${lab}</td><td>${cnt}</td><td>${pct}%</td>`;
      distBody.appendChild(tr);
    }

    const trTotal = document.createElement('tr');
    trTotal.innerHTML = `<td><strong>Total</strong></td><td><strong>${totalCounts}</strong></td><td><strong>100%</strong></td>`;
    distBody.appendChild(trTotal);

    setTimeout(()=> {
      try{ if(window._distTable) window._distTable.destroy(); } catch(e){}
      window._distTable = new simpleDatatables.DataTable("#distTable", { 
        searchable: true, 
        perPage: 8,
        labels: {
            placeholder: "Buscar...",
            perPage: "registros por página",
            noRows: "No se encontraron registros",
            info: "Mostrando {start} a {end} de {rows} registros"
        }
      });
    }, 80);

    const indicator = INDICATORS.find(i=>i.value===indKey);
    document.getElementById('chartTitle').textContent = indicator ? indicator.label : indKey;
    document.getElementById('chartSubtitle').textContent = `${total} encuestas (${totalCounts} respuestas válidas)`;
    
    const chartType = document.getElementById('selectChartType').value;
    renderChart(chartType, labels, values, indicator ? indicator.label : indKey);
  }

  /***************************************************************************
   * Filtering helper
   ***************************************************************************/
  function applyFilters(rows){
    const sexo = document.getElementById('filterSexo').value;
    const grupo = document.getElementById('filterGrupo').value;
    let filtered = rows.slice();
    if(sexo && sexo!=='todos') filtered = filtered.filter(r => normalize(r.sexo) === sexo);
    if(grupo && grupo!=='todos') filtered = filtered.filter(r => normalize(r.grupo) === grupo);
    return filtered;
  }

  /***************************************************************************
   * Main rendering flow
   ***************************************************************************/
  async function refreshAll(){
    try {
      const data = await fetchAll();
      if (data.length === 0) {
        document.getElementById('cardTotal').textContent = '0';
        document.getElementById('noDataMsg').classList.remove('hidden');
        return;
      }
      
      populateGroupFilter(data);
      updateCardsInitial(data);

      const ind = document.getElementById('selectIndicator').value || INDICATORS[0].value;
      const filtered = applyFilters(data);
      const processed = processIndicator(ind, filtered);
      updateUIForIndicator(ind, processed, filtered);
    } catch (error) {
      console.error("Error in refreshAll:", error);
    }
  }

  function updateCardsInitial(data){
    document.getElementById('cardTotal').textContent = data.length;
  }

  document.addEventListener('change', async (e)=>{
    if(['selectIndicator','selectChartType','filterSexo','filterGrupo'].includes(e.target.id)){
      const all = window.__RAW || [];
      if (all.length === 0) return;
      
      const filtered = applyFilters(all);
      const ind = document.getElementById('selectIndicator').value;
      const processed = processIndicator(ind, filtered);
      updateUIForIndicator(ind, processed, filtered);
    }
  });

  function exportCSV(){
    const rows = window.__RAW || [];
    if(!rows.length) return alert('No hay datos para exportar.');
    const cols = Object.keys(rows[0]);
    const csv = [cols.join(',')].concat(rows.map(r=> cols.map(c=>{
      const v = r[c]===null||r[c]===undefined ? '' : String(r[c]).replace(/"/g,'""');
      return v.includes(',')||v.includes('\n') ? `"${v}"` : v;
    }).join(','))).join('\n');
    const blob = new Blob([csv], { type:'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); 
    a.href = url; 
    a.download = `datos_${new Date().toISOString().split('T')[0]}.csv`; 
    a.click(); 
    URL.revokeObjectURL(url);
  }
  
  document.getElementById('btnExportCSV').addEventListener('click', exportCSV);

  document.getElementById('btnExportChart').addEventListener('click', ()=>{
    if(!chart) return alert('No hay gráfico para exportar.');
    const url = document.getElementById('mainChart').toDataURL('image/png',1);
    const a = document.createElement('a'); 
    a.href = url; 
    a.download = `grafico_${new Date().toISOString().split('T')[0]}.png`; 
    a.click();
  });

  /***************************************************************************
   * INIT
   ***************************************************************************/
  (async function init(){
    populateIndicators();
    
    showConnectionSuccess("Conectando a Supabase...");
    
    try {
      await refreshAll();
    } catch (error) {
      console.error("Error en inicialización:", error);
      showConnectionError("Error al inicializar la aplicación: " + error.message);
    }
  })();

  </script>

</body>
</html>
